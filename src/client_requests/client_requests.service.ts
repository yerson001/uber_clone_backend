import { Client, DistanceMatrixResponseData, TravelMode } from '@googlemaps/google-maps-services-js';
import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { TimeAndDistanceValuesService } from '../time_and_distance_values/time_and_distance_values.service';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ClientRequests, Status } from './client_requests.entity';
import { CreateClientRequestDto } from './dto/create_client_request.dto';
import { UpdateDriverAssignedClientRequestDto } from './dto/update_driver_assigned_client_request.dto';
import { UpdateStatusClientRequestDto } from './dto/update_status_client_request.dto';
import { UpdateDriverRatingDto } from './dto/update_driver_rating.dto';
import { UpdateClientRatingDto } from './dto/update_client_rating.dto';
import { FirebaseRepository } from 'src/firebase/firebase.repository';
import { ConfigService } from '@nestjs/config';



@Injectable()
export class ClientRequestsService extends Client {
    private readonly apiKey: string;

    constructor(
        @InjectRepository(ClientRequests) private clientRequestsRepository: Repository<ClientRequests>,
        private timeAndDistanceValuesService: TimeAndDistanceValuesService,
        private firebaseRepository: FirebaseRepository,
        private configService: ConfigService,
    ) {
        super();
        this.apiKey = this.configService.get<string>('GOOGLE_API_KEY');
    }

async create(clientRequest: CreateClientRequestDto) {
    try {
        console.log("=== INICIO DEBUG NOTIFICACIONES ===");

        // Insertar la solicitud del cliente
        await this.clientRequestsRepository.query(`
            INSERT INTO
                client_requests(
                    id_client,
                    fare_offered,
                    pickup_description,
                    destination_description,
                    pickup_position,
                    destination_position
                )
            VALUES(
                ${clientRequest.id_client},
                '${clientRequest.fare_offered}',
                '${clientRequest.pickup_description}',
                '${clientRequest.destination_description}',
                ST_GeomFromText('POINT(${clientRequest.pickup_lat} ${clientRequest.pickup_lng})', 4326),
                ST_GeomFromText('POINT(${clientRequest.destination_lat} ${clientRequest.destination_lng})', 4326)
            )
        `);

        const data = await this.clientRequestsRepository.query(`SELECT MAX(id) AS id FROM client_requests`);
        console.log("‚úÖ ID de solicitud creada:", data[0].id);

        // Query para obtener TODOS los usuarios con token
        const allUsersWithTokens = await this.clientRequestsRepository.query(`
            SELECT
                U.id,
                U.name,
                U.notification_token
            FROM
                users AS U
            WHERE
                U.notification_token IS NOT NULL 
                AND U.notification_token != ''
                AND TRIM(U.notification_token) != ''
        `);

        console.log("üì± Usuarios con token encontrados:", allUsersWithTokens.length);

        // Procesar tokens
        const notificationTokens = [];
        allUsersWithTokens.forEach((user) => {
            if (user.notification_token && user.notification_token.trim() !== "") {
                const cleanToken = user.notification_token.trim();
                if (!notificationTokens.includes(cleanToken)) {
                    notificationTokens.push(cleanToken);
                }
            }
        });

        console.log("üéØ TOKENS FINALES:", notificationTokens);
        console.log("üìä Cantidad de tokens:", notificationTokens.length);

        if (notificationTokens.length > 0) {
            const notificationPayload = {
                tokens: notificationTokens,
                notification: {
                    title: "Solicitud de Incidente",
                    body: clientRequest.pickup_description
                },
                data: {
                    id_client_request: `${data[0].id}`,
                    type: 'CLIENT_REQUEST'
                },
                android: {
                    priority: "high",
                    notification: {
                        channelId: "default_channel"
                    }
                }
            };

            console.log("üöÄ ENVIANDO NOTIFICACIONES...");

            try {
                // Enviar con el m√©todo principal
                const result = await this.firebaseRepository.sendMessageToMultipleDevices(notificationPayload);
                console.log("üìà RESULTADO FINAL:", result);

                // Si fall√≥, probar individualmente
                if (result.failureCount > 0) {
                    console.log("üîÑ Probando env√≠o individual por fallos...");
                    const individualResults = await this.firebaseRepository.sendToEachDeviceIndividually(notificationPayload);
                    console.log("üîç RESULTADOS INDIVIDUALES:", individualResults);
                }

            } catch (sendError) {
                console.log("üí• ERROR AL ENVIAR:", sendError);
                
                // Como fallback, probar env√≠o individual
                console.log("üÜò FALLBACK: Probando env√≠o individual...");
                try {
                    const individualResults = await this.firebaseRepository.sendToEachDeviceIndividually(notificationPayload);
                    console.log("üîß RESULTADOS FALLBACK:", individualResults);
                } catch (fallbackError) {
                    console.log("üíÄ FALL√ì TODO:", fallbackError);
                }
            }
        } else {
            console.log("‚ö†Ô∏è NO HAY TOKENS V√ÅLIDOS");
        }

        console.log("=== FIN DEBUG NOTIFICACIONES ===");
        return Number(data[0].id);
    } catch (error) {
        console.log('‚ùå ERROR EN CREATE:', error);
        throw new HttpException('Error del servidor', HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

    async updateDriverAssigned(driverAssigned: UpdateDriverAssignedClientRequestDto) {
        try {
            await this.clientRequestsRepository.query(`
                UPDATE
                    client_requests
                SET
                    id_driver_assigned = ${driverAssigned.id_driver_assigned},
                    status = '${Status.ACCEPTED}',
                    updated_at = NOW(),
                    fare_assigned = '${driverAssigned.fare_assigned}'
                WHERE
                    id = ${driverAssigned.id}
            `);

            return true;
        } catch (error) {
            console.log('Error creando la solicitud del cliente', error);
            throw new HttpException('Error del servidor', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async updateStatus(updateStatusDto: UpdateStatusClientRequestDto) {
        try {
            await this.clientRequestsRepository.query(`
                UPDATE
                    client_requests
                SET
                    status = '${updateStatusDto.status}',
                    updated_at = NOW()
                WHERE
                    id = ${updateStatusDto.id_client_request}
            `);

            return true;
        } catch (error) {
            console.log('Error creando la solicitud del cliente', error);
            throw new HttpException('Error del servidor', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async updateDriverRating(driverRating: UpdateDriverRatingDto) {
        try {
            await this.clientRequestsRepository.query(`
                UPDATE
                    client_requests
                SET
                    driver_rating = '${driverRating.driver_rating}',
                    updated_at = NOW()
                WHERE
                    id = ${driverRating.id_client_request}
            `);

            return true;
        } catch (error) {
            console.log('Error creando la solicitud del cliente', error);
            throw new HttpException('Error del servidor', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async updateClientRating(driverRating: UpdateClientRatingDto) {
        try {
            await this.clientRequestsRepository.query(`
                UPDATE
                    client_requests
                SET
                    client_rating = '${driverRating.client_rating}',
                    updated_at = NOW()
                WHERE
                    id = ${driverRating.id_client_request}
            `);

            return true;
        } catch (error) {
            console.log('Error creando la solicitud del cliente', error);
            throw new HttpException('Error del servidor', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getByClientRequest(id_client_request: number) {
        const data = await this.clientRequestsRepository.query(`
        SELECT
            CR.id,
            CR.id_client,
            CR.fare_offered,
            CR.pickup_description,
            CR.destination_description,
            CR.status,
            CR.updated_at,
            CR.pickup_position,
            CR.destination_position,
            CR.fare_assigned,
            CR.id_driver_assigned,
            JSON_OBJECT(
                "name", U.name,
                "lastname", U.lastname,
                "phone", U.phone,
                "image", U.image
            ) AS client,
            JSON_OBJECT(
                "name", D.name,
                "lastname", D.lastname,
                "phone", D.phone,
                "image", D.image
            ) AS driver,
            JSON_OBJECT(
                "brand", DCI.brand,
                "plate", DCI.plate,
                "color", DCI.color
            ) AS car
        FROM 
            client_requests AS CR
        INNER JOIN
            users AS U
        ON
            U.id = CR.id_client
        LEFT JOIN
            users AS D
        ON
            D.id = CR.id_driver_assigned
        LEFT JOIN
            driver_car_info AS DCI
        ON
            DCI.id_driver = CR.id_driver_assigned
        WHERE
            CR.id = ${id_client_request} AND CR.status = '${Status.ACCEPTED}'
        `);
        return {
            ...data[0],
            'pickup_lat': data[0].pickup_position.y,
            'pickup_lng': data[0].pickup_position.x,
            'destination_lat': data[0].destination_position.y,
            'destination_lng': data[0].destination_position.x,
        };
    }

    async getByDriverAssigned(id_driver: number) {
        const data = await this.clientRequestsRepository.query(`
        SELECT
            CR.id,
            CR.id_client,
            CR.fare_offered,
            CR.pickup_description,
            CR.destination_description,
            CR.status,
            CR.updated_at,
            CR.created_at,
            CR.pickup_position,
            CR.destination_position,
            CR.fare_assigned,
            CR.id_driver_assigned,
            CR.driver_rating,
            CR.client_rating,
            JSON_OBJECT(
                "name", U.name,
                "lastname", U.lastname,
                "phone", U.phone,
                "image", U.image
            ) AS client,
            JSON_OBJECT(
                "name", D.name,
                "lastname", D.lastname,
                "phone", D.phone,
                "image", D.image
            ) AS driver,
            JSON_OBJECT(
                "brand", DCI.brand,
                "plate", DCI.plate,
                "color", DCI.color
            ) AS car
        FROM 
            client_requests AS CR
        INNER JOIN
            users AS U
        ON
            U.id = CR.id_client
        LEFT JOIN
            users AS D
        ON
            D.id = CR.id_driver_assigned
        LEFT JOIN
            driver_car_info AS DCI
        ON
            DCI.id_driver = CR.id_driver_assigned
        WHERE
            CR.id_driver_assigned = ${id_driver} AND CR.status = '${Status.FINISHED}'
        `);
        return data;
    }

    async getByClientAssigned(id_client: number) {
        const data = await this.clientRequestsRepository.query(`
        SELECT
            CR.id,
            CR.id_client,
            CR.fare_offered,
            CR.pickup_description,
            CR.destination_description,
            CR.status,
            CR.updated_at,
            CR.created_at,
            CR.pickup_position,
            CR.destination_position,
            CR.fare_assigned,
            CR.id_driver_assigned,
            CR.driver_rating,
            CR.client_rating,
            JSON_OBJECT(
                "name", U.name,
                "lastname", U.lastname,
                "phone", U.phone,
                "image", U.image
            ) AS client,
            JSON_OBJECT(
                "name", D.name,
                "lastname", D.lastname,
                "phone", D.phone,
                "image", D.image
            ) AS driver,
            JSON_OBJECT(
                "brand", DCI.brand,
                "plate", DCI.plate,
                "color", DCI.color
            ) AS car
        FROM 
            client_requests AS CR
        INNER JOIN
            users AS U
        ON
            U.id = CR.id_client
        LEFT JOIN
            users AS D
        ON
            D.id = CR.id_driver_assigned
        LEFT JOIN
            driver_car_info AS DCI
        ON
            DCI.id_driver = CR.id_driver_assigned
        WHERE
            CR.id_client = ${id_client} AND CR.status = '${Status.FINISHED}'
        `);
        return data;
    }

    async getNearbyTripRequest(driver_lat: number, driver_lng: number) {
        const data = await this.clientRequestsRepository.query(`
        SELECT
            CR.id,
            CR.id_client,
            CR.fare_offered,
            CR.pickup_description,
            CR.destination_description,
            CR.status,
            CR.updated_at,
            CR.pickup_position,
            CR.destination_position,
            ST_Distance_Sphere(pickup_position, ST_GeomFromText('POINT(${driver_lat} ${driver_lng})', 4326)) AS distance,
            timestampdiff(MINUTE, CR.updated_at, NOW()) AS time_difference,
        JSON_OBJECT(
            "name", U.name,
            "lastname", U.lastname,
            "phone", U.phone,
            "image", U.image
        ) AS client
        FROM 
            client_requests AS CR
        INNER JOIN
            users AS U
        ON
            U.id = CR.id_client
        WHERE
            timestampdiff(MINUTE, CR.updated_at, NOW()) < 5000 AND CR.status = '${Status.CREATED}'
        HAVING
            distance < 10000
        `);
        if (data.length > 0) {
            const pickup_positions = data.map(d => ({
                lat: d.pickup_position.y,
                lng: d.pickup_position.x
            }));

            const googleResponse = await this.distancematrix({
                params: {
                    mode: TravelMode.driving,

                    key: this.apiKey,
                    origins: [
                        {
                            lat: driver_lat,
                            lng: driver_lng
                        }
                    ],
                    destinations: pickup_positions
                }
            });

            data.forEach((d, index) => {
                d.google_distance_matrix = googleResponse.data.rows[0].elements[index];
            });
        }
        return data;
    }

    async getTimeAndDistanceClientRequest(
        origin_lat: number,
        origin_lng: number,
        destination_lat: number,
        destination_lng: number,
    ) {

        const values = await this.timeAndDistanceValuesService.find();
        const kmValue = values[0].km_value;
        const minValue = values[0].min_value;

        const googleResponse = await this.distancematrix({
            params: {
                mode: TravelMode.driving,
                key: this.apiKey,
                origins: [
                    {
                        lat: origin_lat,
                        lng: origin_lng
                    }
                ],
                destinations: [
                    {
                        lat: destination_lat,
                        lng: destination_lng
                    }
                ]
            }
        });

        const recommendedValue = (kmValue * (googleResponse.data.rows[0].elements[0].distance.value / 1000)) + (minValue * (googleResponse.data.rows[0].elements[0].duration.value / 60))

        return {
            'recommended_value': recommendedValue,
            'destination_addresses': googleResponse.data.destination_addresses[0],
            'origin_addresses': googleResponse.data.origin_addresses[0],
            'distance': {
                'text': googleResponse.data.rows[0].elements[0].distance.text,
                'value': (googleResponse.data.rows[0].elements[0].distance.value / 1000)
            },
            'duration': {
                'text': googleResponse.data.rows[0].elements[0].duration.text,
                'value': (googleResponse.data.rows[0].elements[0].duration.value / 60)
            },
        };
    }


}
